Brammm\CommonBundle
===================

[![Build Status](https://travis-ci.org/Brammm/CommonBundle.png?branch=master)](https://travis-ci.org/Brammm/CommonBundle)

A strongly opinionated bundle that provides some common functionality for your Symfony2 bundles.

## Opionions

- View files go in `app/`, not `src/`. To be exact, they go in `app/views/Bundle/Controller/method.html.twig`.
- Controllers are defined as services. Extend `Brammm\CommonBundle\Controller\Controller` for a good base.
- Every entity has a repository. Repositories should be defined as services so they can be injected.
- Every entity has a manager service. Managers keep the heavy lifting out of the controller.
- Controller actions don't persist or flush. This happens in the managers.
- Controller actions don't return responses, only data. The response is generated by a view listener.
 
## Install

Via Composer (the bundle isn't added to Packagist just yet, so you have to add the repository manually):

```json
{
    "repositories": [
        {
            "url": "https://github.com/Brammm/CommonBundle.git",
            "type": "git"
        }
    ],
    "require": {
        "brammm/common-bundle": "dev-master"
    }
}
```

## Usage

### Controllers as services

Define your controllers as services. They can extend the base controller for some basic functionality. 

```xml
<service id="acme_demo.controller.home"
         parent="brammm_common.controller.base"
         class="Acme\DemoBundle\Controller\HomeController">
    <argument type="service" id="some.service" />
</service>
```

**Note:** The base controller does not know about the `Container`. No magic `$this->get()`. Inject the services you really need. `@event_dispatcher` and `@form.factory` are available by default via their getters. [Inject `Request` in your controllers](http://symfony.com/doc/current/book/controller.html#the-request-as-a-controller-argument). Note that you can get the session from the request.

#### Controller helper methods

The base controller provides some basic helper methods.

- `createForm($request, $type, $data, $options)` generates a form you can render in views etc. It also fires a `controller.form_created` event which you can use to handle certain things.
- `processForm($form, $request)` returns a boolean telling you if the form is ready to be saved. It automatically handles the request for you as well.

### Repositories and managers

By providing each entity with a repository and a manager, you can separate any logic from your controllers and make everything more manageable.

**Repositories** are responsible for querying the database, **managers** are responsible for manipulating and writing to the database.

#### Repositories

You can declare a repository as a service by using the EntityManager as a factory.

```xml
<service id="acme_demo.repository.blog"
         class="Acme\DemoBundle\Repository\BlogRepository"
         factory-service="doctrine.orm.entity_manager"
         factory-method="getRepository">
    <argument>AcmeDemoBundle:Blog</argument>
</service>
```

#### Managers

Managers can extend the base Manager service. This will provide you with the Doctrine EntityManager in your own managers. 

```xml
<service id="acme_demo.manager.blog"
         parent="brammm_common.manager"
         class="Acme\DemoBundle\Manager\BlogManager">
</service>
```

A manager method could be `save($blog)` that simply persists a Blog entity and flushes it, but also could do more elaborate stuff as dispatch events, manipulate data, generate associated entitiies...

### Handling responses

This bundle registers a default view listener that will render the data returned by the controller into a response. At the moment, there are two renderers provided:

- JsonRenderer: renders a simple `JsonResponse` of the provided data
- TemplateRenderer: renders a Twig template as response, guesses where the template should be. 

#### Determining the renderer

By default, the TemplateRenderer will be used. If you want to change this, you can configure this as follows:

```yaml
brammm_common:
    response:
        default: json # default template
```

You can override the renderer used by configuring the response types under the `types` configuration:

```yaml
brammm_common:
    response:
        types:
            acme_api.*: json
```

The provided associative array should consist of keys that are Regex patterns that match the _controller param for your controller, the value is the rendertype you wish to use.

#### Providing additional renderers

If you would like to provide additional renderers, you can do so. Simply create a service that implements the `RendererInterface` and tag the service as follows

```xml
<service id="acme_demo.my_renderer" class="Acme\DemoBundle\Renderer\MyRenderer">
    <tag name="response_renderer" type="mine" />
</service>
```

## Contributing

Go right ahead, submit a PR. I'm open to suggestions.

## License

The MIT License (MIT). Please see [License File](https://github.com/Brammm/CommonBundle/blob/master/Resources/meta/LICENSE) for more information.